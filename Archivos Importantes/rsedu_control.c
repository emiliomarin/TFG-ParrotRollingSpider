//File: rsedu_control.c
/*
* AUTHOR Fabian Riether
* CREATE DATE 2015/08/25
* PURPOSE This module takes care of fully controlling the drone: Stabilizing based on sensor measurements, crash handling. For this purpose, it also calls the simulink-model.
* SPECIAL NOTES
* ===============================
* Change History
* 2015/08/25 created
* ==================================
*/


//frameworkparameters
//-------------------
#ifndef RSEDU_PARAMS_H_
#include "rsedu_params.h"
#endif

//control
//-------------------
//#include "rsedu_control.h"		/* might be declared differently for existing other code on drone itself, therefore do not create that file yourself */
#include "HAL.h"
#include "DroneRS_Compensator.h"
#include "rtwtypes.h"
#include <math.h>
#include <inttypes.h>
#include <stddef.h>

//data logging
#include "builtin_typeid_types.h"
#include "multiword_types.h"
#include "rt_logging.h"
#define QUOTE1(name)                   #name
#define QUOTE(name)                    QUOTE1(name)              /* need to expand name */
#ifndef SAVEFILE
# define MATFILE2(file)                #file ".mat"
# define MATFILE1(file)                MATFILE2(file)
# define MATFILE                       MATFILE1(/data/edu/RSdata)
#else
# define MATFILE                       QUOTE(SAVEFILE)
#endif

//communication
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/fcntl.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <pthread.h>

//set 'default' enabled feature set if paramsEDU.dat not found. Note: those variables are extern (declared in framework.h and defined here)
//--------------------------
int FEAT_TIME 		= 0; 	//Activa guardado de tiempos; 1  guardo entrada y salida de los tiempos de las funciones en /tmp/edu/ptimes/pt_RS_x.txt
int FEAT_OF_ACTIVE 	= 0; 	// Los resultados del flujo opticos son leidos por el control y usados en simulink para la estimacion de velocidad
int FEAT_POSVIS_RUN	= 0; 	//Activa procesamiento de imagenes 
int FEAT_POSVIS_USE = 0; 	//Incluye los resultados de vision en la estimacion de posicion  estimation
int FEAT_IMSAVE 	= 0;	//Guardado de imagenes ; 0 descarta images, 1 las guarda, 2 activa streaming;
int FEAT_NOLOOK 	= 0;	
int FEAT_NOSAFETY 	= 0;	//1: el drone no se apaga al sufrir un choque 

// Tiempos de despegue, calibracion: en numero de ciclos
int onCycles 		= 8000; // 4000 = 20segundos totales 
int calibCycles 	= 400;
int takeoffCycles	= 170; // 200 para PID - 140 LQR - 170 para FSF

extern int parar;
int parar_flag = 0;
//-------------------
//SIMULINK compensator block "Parameter definitions"
//-------------------
/*
 * Parameter definitions from the SIMULINK compensator block go here.
 * For this purpose, copy the corresponding lines from ert_main.c from the autogenerated code here (./PackEmbeddedCode does that!)
 */

static RT_MODEL_DroneRS_Compensator_T DroneRS_Compensator_M_;
static RT_MODEL_DroneRS_Compensator_T *const DroneRS_Compensator_M =
  &DroneRS_Compensator_M_;             /* Real-time model */
static P_DroneRS_Compensator_T DroneRS_Compensator_P = {
  {
    13840.8,

    { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0165195073635001, 0.0152648883285633,
      0.0215786550496705, 0.000652733165165932, 0.000721701528439517,
      0.000690781425279554 },

    { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05, 0.05, 0.05, 1.0, 1.0, 1.0 },

    { 0.09, -0.06, 0.337, -0.0095, -0.0075, 0.0015, 101270.95 },

    { 1.00596, 1.00383, 0.99454 },

    { 0.99861, 1.00644 },
    0.99997,
    1.225,
    12.01725,
    0.05,

    { 0.99407531114557246, 0.99618461293246863, 1.0054899752649467,
      1.0013919347893572, 0.99360120821906917, 1.0000300009000269 },
    0.44,
    0.005,

    { -99.0, 0.0, 0.0, -9.0 },
    0.0,
    0.1,
    0.05,
    -30.0,
    20.0
  },                                   /* Variable: quadEDT
                                        * Referenced by:
                                        *   '<S24>/prsToAlt_Gain'
                                        *   '<S27>/inversesIMU_Gain'
                                        *   '<S11>/W2ToMotorsCmd_Gain'
                                        *   '<S29>/SaturationSonar'
                                        *   '<S82>/opticalFlowToVelocity_Gain'
                                        *   '<S80>/Constant'
                                        */

  {
    4.0,
    9.81,
    1.184,
    1.5e-5,
    0.068,

    { 8.0299999999999987e-5, 1.1699999999999996e-5, 0.0, 1.1699999999999995e-5,
      8.03e-5, 0.0, 0.0, 0.0, 0.0001366 },
    -0.015875999999999998,
    0.0624,
    2.0,
    0.033,
    0.008,
    0.0,
    0.000375,
    0.0,
    0.0,
    1.0209375000000001e-7,
    0.0,
    6.0699375000000009e-5,
    2.0418750000000001e-7,
    0.0107,
    0.00078263752785053692,
    0.15433206602850458,
    0.11868238913561441,
    0.25481807079117214,
    -0.13613568165555773,
    0.15271630954950383,
    10000.0,
    5.5,
    0.0034211943997592849,
    0.605147136,
    4.7199903669109095e-8,
    1.1392838555498841e-10,
    0
  },                                   /* Variable: quad
                                        * Referenced by:
                                        *   '<S10>/HoverThrustLinearizationPoint'
                                        *   '<S11>/ThrustToW2_Gain'
                                        */

  {
    { 0.28212412246252067, 1.272539291716861, 2.4208439774454473,
      2.4208439774454487, 1.272539291716863, 0.28212412246252133 },

    { 1.0, 2.2287149173647665, 2.5244618916938606, 1.5772531712757014,
      0.541022406829817, 0.079562396085500781 },

    { 0.007509257528603033, -0.022498139897706472, 0.014988905760749172,
      0.014988905760749172, -0.022498139897706455, 0.0075092575286030234 },

    { 1.0, -4.89810443312637, 9.5974881329446688, -9.4036722433820046,
      4.60730099744654, -0.90301240709954322 },
    0.3,
    0.8,
    0.4
  },                                   /* Variable: altEstim
                                        * Referenced by:
                                        *   '<S24>/Bias'
                                        *   '<S24>/Bias1'
                                        *   '<S27>/IIRgyroz'
                                        *   '<S29>/IIRprs'
                                        *   '<S29>/IIRsonar'
                                        *   '<S78>/Constant'
                                        *   '<S79>/Constant'
                                        *   '<S81>/Constant'
                                        *   '<S86>/IIRgyroz'
                                        */

  {
    0.6,
    7.0,
    0.5,
    80.0,
    -0.4,
    5.0
  },                                   /* Variable: ofhandle
                                        * Referenced by:
                                        *   '<S134>/Constant'
                                        *   '<S135>/Constant'
                                        *   '<S136>/Constant'
                                        *   '<S137>/Constant'
                                        *   '<S138>/Constant'
                                        *   '<S139>/Constant'
                                        *   '<S140>/Constant'
                                        *   '<S141>/Constant'
                                        *   '<S142>/Constant'
                                        *   '<S143>/Constant'
                                        *   '<S144>/Constant'
                                        */

  {
    0.18,
    0.5
  },                                   /* Variable: vishandle
                                        * Referenced by:
                                        *   '<S195>/Constant'
                                        *   '<S196>/Constant'
                                        *   '<S197>/Constant'
                                        */

  /*  Variable: K_poleplace
   * Referenced by: '<S6>/Gain'
   */
  { 0.0, 0.0, -0.0026773635963302745, 0.0, 0.0, 0.0, 0.0, 0.009025565749235475,
    1.7340000000000002, 0.0, 0.0, 0.0, 0.0, 0.0012703799999999937, 0.0, 0.0, 0.0,
    0.0, 0.0086952146399999972, 0.0, 0.0, 0.0, 0.0, 0.023626520000000005, 0.0,
    0.0, -0.00070644154128440253, 0.0, 0.0, 0.0, 0.0, 0.0028569704383282421,
    0.6868, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0059063999999999974, 0.0, 0.0,
    0.0012594959999999997, 0.0, 0.0, 0.00083325999999999789, 0.0, 0.0 },
  0.005,                               /* Variable: sampleTime_qcsim
                                        * Referenced by: '<S5>/sampleTime'
                                        */

  /* Start of '<Root>/DroneRS_Compensator' */
  {
    0.0,                               /* Mask Parameter: DiscreteDerivative_ICPrevScaled
                                        * Referenced by: '<S133>/UD'
                                        */
    -99.0,                             /* Mask Parameter: checkPosavailable_const
                                        * Referenced by: '<S194>/Constant'
                                        */
    -99.0,                             /* Mask Parameter: CompareToConstant_const
                                        * Referenced by: '<S198>/Constant'
                                        */
    0.0,                               /* Mask Parameter: outlierBelowFloor_const
                                        * Referenced by: '<S32>/Constant'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S27>/FIRaccelero'
                                        */

    /*  Expression: controlParams.filter_accelero.Coefficients
     * Referenced by: '<S27>/FIRaccelero'
     */
    { 0.026407724923238066, 0.14053136276241623, 0.3330609123143457,
      0.3330609123143457, 0.14053136276241623, 0.026407724923238066 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S27>/IIRgyroz'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S83>/Delay'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S148>/KalmanGainM'
     */
    { 0.005756860081440762, 0.0, 0.0, 0.005756860081440762 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S86>/IIRgyroz'
                                        */
    200.0,                             /* Computed Parameter: TSamp_WtEt
                                        * Referenced by: '<S133>/TSamp'
                                        */
    -1.0,                              /* Expression: -1
                                        * Referenced by: '<S24>/invertzaxisGain'
                                        */
    0.0,                               /* Expression: -inf
                                        * Referenced by: '<S29>/SaturationSonar'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S24>/Delay2'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S29>/IIRprs'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S29>/IIRsonar'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S33>/KalmanGainM'
     */
    { 0.026241420641871072, 0.069776736071495274 },

    /*  Expression: [0 0 quad.g]
     * Referenced by: '<S24>/gravity'
     */
    { 0.0, 0.0, 9.81 },

    /*  Expression: pInitialization.C
     * Referenced by: '<S28>/C'
     */
    { 1.0, 0.0 },
    0.0,                               /* Expression: pInitialization.D
                                        * Referenced by: '<S28>/D'
                                        */

    /*  Expression: pInitialization.X0
     * Referenced by: '<S28>/X0'
     */
    { -0.046, 0.0 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S82>/Delay'
                                        */

    /*  Expression: pInitialization.M
     * Referenced by: '<S88>/KalmanGainM'
     */
    { 0.1254656089860898, 0.0, 0.0, 0.1254656089860898 },

    /*  Expression: [0 0 -quad.g]
     * Referenced by: '<S84>/gravity'
     */
    { 0.0, 0.0, -9.81 },
    0.2,                               /* Expression: 0.2
                                        * Referenced by: '<S84>/gainaccinput'
                                        */

    /*  Expression: pInitialization.C
     * Referenced by: '<S85>/C'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.D
     * Referenced by: '<S85>/D'
     */
    { 0.0, 0.0, 0.0, 0.0 },

    /*  Expression: pInitialization.X0
     * Referenced by: '<S85>/X0'
     */
    { 0.0, 0.0 },
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S5>/Delay1'
                                        */

    /*  Expression: pInitialization.C
     * Referenced by: '<S145>/C'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.D
     * Referenced by: '<S145>/D'
     */
    { 0.0, 0.0, 0.0, 0.0 },

    /*  Expression: pInitialization.X0
     * Referenced by: '<S145>/X0'
     */
    { 0.1, 0.0 },
    0.005,                             /* Computed Parameter: SimplyIntegrateVelocity_gainval
                                        * Referenced by: '<S83>/SimplyIntegrateVelocity'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S83>/SimplyIntegrateVelocity'
                                        */
    2.0,                               /* Expression: 2
                                        * Referenced by: '<S83>/SimplyIntegrateVelocity'
                                        */
    -2.0,                              /* Expression: -2
                                        * Referenced by: '<S83>/SimplyIntegrateVelocity'
                                        */
    0.0,                               /* Expression: 0
                                        * Referenced by: '<S83>/UseIPPosSwitch'
                                        */

    /*  Expression: pInitialization.A
     * Referenced by: '<S28>/A'
     */
    { 1.0, 0.0, 0.005, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S28>/B'
     */
    { 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S33>/KalmanGainL'
     */
    { 0.026590304322228548, 0.069776736071495274 },

    /*  Expression: pInitialization.A
     * Referenced by: '<S85>/A'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S85>/B'
     */
    { 0.005, 0.0, 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S88>/KalmanGainL'
     */
    { 0.1254656089860898, 0.0, 0.0, 0.1254656089860898 },

    /*  Expression: pInitialization.A
     * Referenced by: '<S145>/A'
     */
    { 1.0, 0.0, 0.0, 1.0 },

    /*  Expression: pInitialization.B
     * Referenced by: '<S145>/B'
     */
    { 0.005, 0.0, 0.0, 0.005 },

    /*  Expression: pInitialization.L
     * Referenced by: '<S148>/KalmanGainL'
     */
    { 0.005756860081440762, 0.0, 0.0, 0.005756860081440762 },
    1U,                                /* Computed Parameter: Delay_DelayLength
                                        * Referenced by: '<S83>/Delay'
                                        */
    1U,                                /* Computed Parameter: Delay2_DelayLength
                                        * Referenced by: '<S24>/Delay2'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength
                                        * Referenced by: '<S28>/MemoryX'
                                        */
    1U,                                /* Computed Parameter: Delay_DelayLength_g
                                        * Referenced by: '<S82>/Delay'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength_g
                                        * Referenced by: '<S85>/MemoryX'
                                        */
    1U,                                /* Computed Parameter: Delay1_DelayLength
                                        * Referenced by: '<S5>/Delay1'
                                        */
    1U,                                /* Computed Parameter: MemoryX_DelayLength_m
                                        * Referenced by: '<S145>/MemoryX'
                                        */

    /* Start of '<S1>/ControllerFSFB' */
    {
      0.05,                            /* Expression: controlParams.takeoff_Gain
                                        * Referenced by: '<S10>/takeoff_Gain'
                                        */
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S8>/dz_ref'
                                        */

      /*  Expression: [0;0;0]
       * Referenced by: '<S8>/velocitiesPos_ref'
       */
      { 0.0, 0.0, 0.0 },

      /*  Expression: [0;0;0]
       * Referenced by: '<S8>/velocitiesRot_ref'
       */
      { 0.0, 0.0, 0.0 },

      /*  Expression: controlParams.Q2Ts
       * Referenced by: '<S9>/TorquetotalThrustToThrustperMotor'
       */
      { 0.25, 0.25, 0.25, 0.25, 103.57362530676717, -103.57362530676717,
        103.57362530676717, -103.57362530676717, -5.6659197210460537,
        -5.6659197210460546, 5.6659197210460546, 5.6659197210460546,
        -5.6659197210460546, 5.6659197210460546, 5.6659197210460546,
        -5.6659197210460546 },
      0.0,                             /* Expression: 0
                                        * Referenced by: '<S12>/Constant'
                                        */
      1.2020433451342656,              /* Expression: controlParams.totalThrust_maxRelative*controlParams.motorsThrust_i_UpperLimit*4
                                        * Referenced by: '<S10>/SaturationThrust'
                                        */
      -1.2020433451342656,             /* Expression: -(controlParams.totalThrust_maxRelative*controlParams.motorsThrust_i_UpperLimit*4)
                                        * Referenced by: '<S10>/SaturationThrust'
                                        */
      -0.0118,                         /* Expression: -0.0118
                                        * Referenced by: '<S9>/Saturation2'
                                        */
      -0.3235,                         /* Expression: -0.3235
                                        * Referenced by: '<S9>/Saturation2'
                                        */

      /*  Expression: [-1,1,-1,1]
       * Referenced by: '<S11>/MotorsRotationDirection'
       */
      { -1.0, 1.0, -1.0, 1.0 }
    }
    /* End of '<S1>/ControllerFSFB' */
  }
  /* End of '<Root>/DroneRS_Compensator' */
};                                     /* Modifiable parameters */

//-------------------
// END OF SIMULINK compensator block "Parameter definitions"
//-------------------


//-------------------
//SIMULINK compensator block "Input/Outputport Declarations" IO(1/3)
//-------------------
/*
 * Input/output port declarations from the SIMULINK compensator block go here.
 * If those were changed, copy the corresponding lines from ert_main.c from the autogenerated code here.
 * Note, that for updating input/output-ports there are code paragraphs to update: IO(1/3), IO(2/3), IO(3/3)
 */

static B_DroneRS_Compensator_T DroneRS_Compensator_B;/* Observable signals */
static DW_DroneRS_Compensator_T DroneRS_Compensator_DW;/* Observable states */

/* '<Root>/controlModePosVSAtt_flagin' */
static boolean_T DroneRS_Compensator_U_controlModePosVSAtt_flagin;

/* '<Root>/pos_refin' */
static real_T DroneRS_Compensator_U_pos_refin[3];

/* '<Root>/attRS_refin' */
static real_T DroneRS_Compensator_U_attRS_refin[3];

/* '<Root>/ddx' */
static real_T DroneRS_Compensator_U_ddx;

/* '<Root>/ddy' */
static real_T DroneRS_Compensator_U_ddy;

/* '<Root>/ddz' */
static real_T DroneRS_Compensator_U_ddz;

/* '<Root>/p' */
static real_T DroneRS_Compensator_U_p;

/* '<Root>/q' */
static real_T DroneRS_Compensator_U_q;

/* '<Root>/r' */
static real_T DroneRS_Compensator_U_r;

/* '<Root>/altitude_sonar' */
static real_T DroneRS_Compensator_U_altitude_sonar;

/* '<Root>/prs' */
static real_T DroneRS_Compensator_U_prs;

/* '<Root>/opticalFlowRS_datin' */
static real_T DroneRS_Compensator_U_opticalFlowRS_datin[3];

/* '<Root>/sensordatabiasRS_datin' */
static real_T DroneRS_Compensator_U_sensordatabiasRS_datin[7];

/* '<Root>/posVIS_datin' */
static real_T DroneRS_Compensator_U_posVIS_datin[4];

/* '<Root>/usePosVIS_flagin' */
static real_T DroneRS_Compensator_U_usePosVIS_flagin;

/* '<Root>/batteryStatus_datin' */
static real_T DroneRS_Compensator_U_batteryStatus_datin[2];

/* '<Root>/motorsRS_cmdout' */
static real_T DroneRS_Compensator_Y_motorsRS_cmdout[4];

/* '<Root>/X' */
static real_T DroneRS_Compensator_Y_X;

/* '<Root>/Y' */
static real_T DroneRS_Compensator_Y_Y;

/* '<Root>/Z' */
static real_T DroneRS_Compensator_Y_Z;

/* '<Root>/yaw' */
static real_T DroneRS_Compensator_Y_yaw;

/* '<Root>/pitch' */
static real_T DroneRS_Compensator_Y_pitch;

/* '<Root>/roll' */
static real_T DroneRS_Compensator_Y_roll;

/* '<Root>/dx' */
static real_T DroneRS_Compensator_Y_dx;

/* '<Root>/dy' */
static real_T DroneRS_Compensator_Y_dy;

/* '<Root>/dz' */
static real_T DroneRS_Compensator_Y_dz;

/* '<Root>/pb' */
static real_T DroneRS_Compensator_Y_pb;

/* '<Root>/qb' */
static real_T DroneRS_Compensator_Y_qb;

/* '<Root>/rb' */
static real_T DroneRS_Compensator_Y_rb;

/* '<Root>/controlModePosVSAtt_flagout' */
static boolean_T DroneRS_Compensator_Y_controlModePosVSAtt_flagout;

/* '<Root>/poseRS_refout' */
static real_T DroneRS_Compensator_Y_poseRS_refout[6];

/* '<Root>/ddxb' */
static real_T DroneRS_Compensator_Y_ddxb;

/* '<Root>/ddyb' */
static real_T DroneRS_Compensator_Y_ddyb;

/* '<Root>/ddzb' */
static real_T DroneRS_Compensator_Y_ddzb;

/* '<Root>/pa' */
static real_T DroneRS_Compensator_Y_pa;

/* '<Root>/qa' */
static real_T DroneRS_Compensator_Y_qa;

/* '<Root>/ra' */
static real_T DroneRS_Compensator_Y_ra;

/* '<Root>/altitude_sonarb' */
static real_T DroneRS_Compensator_Y_altitude_sonarb;

/* '<Root>/prsb' */
static real_T DroneRS_Compensator_Y_prsb;

/* '<Root>/opticalFlowRS_datout' */
static real_T DroneRS_Compensator_Y_opticalFlowRS_datout[3];

/* '<Root>/sensordatabiasRS_datout' */
static real_T DroneRS_Compensator_Y_sensordatabiasRS_datout[7];

/* '<Root>/posVIS_datout' */
static real_T DroneRS_Compensator_Y_posVIS_datout[4];

/* '<Root>/usePosVIS_flagout' */
static real_T DroneRS_Compensator_Y_usePosVIS_flagout;

/* '<Root>/batteryStatus_datout' */
static real_T DroneRS_Compensator_Y_batteryStatus_datout[2];

//-------------------
//END OF SIMULINK compensator block "Input/Outputport Declarations" IO(1/3)
//-------------------

//steps the SIMULINK compensator block model one step
void rt_OneStep(RT_MODEL_DroneRS_Compensator_T *const DroneRS_Compensator_M);
void rt_OneStep(RT_MODEL_DroneRS_Compensator_T *const DroneRS_Compensator_M)
{
  static boolean_T OverrunFlag = false;

  /* Disable interrupts here */

  /* Check for overrun */
  if (OverrunFlag) {
	    rtmSetErrorStatus(DroneRS_Compensator_M, "Overrun");
    return;
  }

  OverrunFlag = true;

  /* Save FPU context here (if necessary) */
  /* Re-enable timer or interrupt here */
  /* Set model inputs here */

  /* Step the model */
  // (IO(2/3): If input-output-ports of the SIMULINK controller block changed, update these lines with the corresponding lines from ert_main.c)
  /* Step the model */
  DroneRS_Compensator_step(DroneRS_Compensator_M,
    DroneRS_Compensator_U_controlModePosVSAtt_flagin,
    DroneRS_Compensator_U_pos_refin, DroneRS_Compensator_U_attRS_refin,
    DroneRS_Compensator_U_ddx, DroneRS_Compensator_U_ddy,
    DroneRS_Compensator_U_ddz, DroneRS_Compensator_U_p, DroneRS_Compensator_U_q,
    DroneRS_Compensator_U_r, DroneRS_Compensator_U_altitude_sonar,
    DroneRS_Compensator_U_prs, DroneRS_Compensator_U_opticalFlowRS_datin,
    DroneRS_Compensator_U_sensordatabiasRS_datin,
    DroneRS_Compensator_U_posVIS_datin, DroneRS_Compensator_U_usePosVIS_flagin,
    DroneRS_Compensator_U_batteryStatus_datin,
    DroneRS_Compensator_Y_motorsRS_cmdout, &DroneRS_Compensator_Y_X,
    &DroneRS_Compensator_Y_Y, &DroneRS_Compensator_Y_Z,
    &DroneRS_Compensator_Y_yaw, &DroneRS_Compensator_Y_pitch,
    &DroneRS_Compensator_Y_roll, &DroneRS_Compensator_Y_dx,
    &DroneRS_Compensator_Y_dy, &DroneRS_Compensator_Y_dz,
    &DroneRS_Compensator_Y_pb, &DroneRS_Compensator_Y_qb,
    &DroneRS_Compensator_Y_rb,
    &DroneRS_Compensator_Y_controlModePosVSAtt_flagout,
    DroneRS_Compensator_Y_poseRS_refout, &DroneRS_Compensator_Y_ddxb,
    &DroneRS_Compensator_Y_ddyb, &DroneRS_Compensator_Y_ddzb,
    &DroneRS_Compensator_Y_pa, &DroneRS_Compensator_Y_qa,
    &DroneRS_Compensator_Y_ra, &DroneRS_Compensator_Y_altitude_sonarb,
    &DroneRS_Compensator_Y_prsb, DroneRS_Compensator_Y_opticalFlowRS_datout,
    DroneRS_Compensator_Y_sensordatabiasRS_datout,
    DroneRS_Compensator_Y_posVIS_datout,
    &DroneRS_Compensator_Y_usePosVIS_flagout,
    DroneRS_Compensator_Y_batteryStatus_datout);
  //-------------------
  //-------------------


  /* Get model outputs here */

  /* Indicate task complete */
  OverrunFlag = false;

  /* Disable interrupts here */
  /* Restore FPU context here (if necessary) */
  /* Enable interrupts here */
}


//--------------------
// RSEDU_control
//--------------------
/* Esta funcion se llama a 200Hz, generando la referencia de los motores basandose en el valor de los sensores
 * @input hal_sensors_data Estructura que contiene el valor de los sensores 
 * @output hal_sensors_cmd Estructura que contiene comando a los motores y leds 
 */
int c = 0; // counter auxiliar

void RSEDU_control(HAL_acquisition_t* hal_sensors_data, HAL_command_t* hal_sensors_cmd)
{
		//Fase de vuelo
		static int run_flag = 1;

		static int counter = 0;
		static int counter_noOF = 0;

		static float MAX_ACCELL 	= 6.0;
		static float MAX_DELTADXY 	= 1.5;
		static float MAX_RANGE 		= 10.0;
		static float MIN_BATTTAKEOFF 	= 50.0;
		static float MIN_BATT		= 30.0;
		static int MAX_noOF 		= 5000; //maximo numero de ciclos sin flujo optico

        int power_usrinpt;
		double powerGain = 0;
		static double powerGain_eparam = 0.1;
        
        //Movimiento de trayectoria
        int mvto = 0;
        
		//Manejo de datos
		static double sensorCal[7];
		static double battLevelAvg;
		float of_data[5];
		float vis_data[4];
		float ofDefined;
		float ofQuality;

		//Comunicacion
		static char serverIP[16];
		static int sockfd = 0;
		static char sendBuff[1024];
		static char recvBuff[100];
		static struct sockaddr_in serv_addr;

		int pitch_ref_buff, roll_ref_buff, yaw_ref_buff, alt_ref_buff;
		
		static int serverstatus;
		static int of_fifo, vis_fifo;

        pthread_t hilo;
        
        
        
		/*-------------------------
		 * PROGRAMA
		 -------------------------*/


		long long start;
		static FILE *ptfile;
		ptimer_start(FEAT_TIME,counter,&(start));
		//------------


		// Create easier aliases

		HAL_acquisition_t* in = hal_sensors_data;
		HAL_command_t    * out = hal_sensors_cmd;
		
		//Vuelo abortado y fin sin run_flag=0
		if (run_flag==0)
			{
			if (counter>calibCycles)
			{
				printf("Saving logged data after %i cycles... \n",counter);
				rt_StopDataLogging(MATFILE, DroneRS_Compensator_M->rtwLogInfo);
			}

			if (FEAT_OF_ACTIVE)
			{
				close(of_fifo);
			}

			if (FEAT_TIME) {close(ptfile);};


			printf("Saving logged data... DONE \n");
			printf("Good night! \n");
			out->motors_speed[0] = 0;
			out->motors_speed[1] = 0;
			out->motors_speed[2] = 0;
			out->motors_speed[3] = 0;
			out->command = BLDC_CMD_STOP;
			usleep(100);
			exit(0);
			}


		//Process Control
		counter++;


		//Fases de vuelo s 0-4
		//--------------

		//s0: Inicializacion (Conexion con servidor , Ajustes de usuario)

		if (counter==1)
		{
			printf("\nBattery output voltage: %5.2f V - %0d percents\n", in->HAL_vbat_SI.vbat_V,(int)in->HAL_vbat_SI.vbat_percentage);
			printf("used: %d, users: %d, gyrotemp %f, acctemp %f, presstmp %f \n",(int)in->used,(int)in->count_user,in->HAL_gyro_SI.temperature,in->HAL_acc_SI.temperature,in->HAL_pressure_SI.temperature);


			//Lectura de parametros

			 FILE *paramFile;
			 paramFile = fopen("/data/edu/params/paramsEDU.dat", "r");
			 if (paramFile == NULL)
			 {
				 printf("ParamsEDU.dat parameter file not found, using default! \n");
			 }

			 else
				 {
				 char tmpbuff[50];
				 char tmpstr1[16];
				 char tmpstr2[16];
				 while(!feof(paramFile))
					 {
						  if (fgets(tmpbuff,50,paramFile))
						  {
							  sscanf(tmpbuff, "%15s : %15[^;];", tmpstr1, tmpstr2);

							  if (!strcmp(tmpstr1,"FEAT_OF_ACTIVE")) 		{FEAT_OF_ACTIVE = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_POSVIS_RUN"))  {FEAT_POSVIS_RUN = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"POWERGAIN"))  		{powerGain_eparam = atoi(tmpstr2)/100.0;}
							  else if (!strcmp(tmpstr1,"FEAT_POSVIS_USE"))  {FEAT_POSVIS_USE = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_NOLOOK"))  	{FEAT_NOLOOK = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_IMSAVE"))    	{FEAT_IMSAVE = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_TIME"))    	{FEAT_TIME = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"FEAT_NOSAFETY"))   	{FEAT_NOSAFETY = atoi(tmpstr2);}
							  else if (!strcmp(tmpstr1,"IP"))    	 		{memcpy(serverIP,tmpstr2,sizeof(tmpstr2));};

						  }
					}
				 fclose(paramFile);
			 }

			 printf("\nSettings:\n -----\n FEAT_TIME: %d \n FEAT_OF_ACTIVE: %d \n FEAT_POSVIS_RUN: %d \n FEAT_POSVIS_USE: %d \n FEAT_NOLOOK: %d \n FEAT_IMSAVE: %d \n FEAT_NOSAFETY: %d \n -----\n",FEAT_TIME, FEAT_OF_ACTIVE,FEAT_POSVIS_RUN,FEAT_POSVIS_USE,FEAT_NOLOOK,FEAT_IMSAVE,FEAT_NOSAFETY);


			//ptiming - init file
			//------------
				ptimer_init(FEAT_TIME,__func__,&(ptfile),&(run_flag));
			//------------



			//-----
			printf("Waiting for connection to reference value server... \n");

			if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
			{
			    printf("\n ERROR : Could not create socket \n");
			    exit(0);
			}

			memset(&serv_addr, '0', sizeof(serv_addr));

			serv_addr.sin_family = AF_INET;
			serv_addr.sin_port = htons(12345);

			if(inet_pton(AF_INET, serverIP, &serv_addr.sin_addr)<=0)
			{
			    printf("ERROR inet_pton error occured (connection to reference value server) \n");
			    exit(0);
			}

			if( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
			{
			   printf("ERROR Connection to reference value server failed \n");
			   serverstatus = 1;
			   exit(0);
			}
			else
			{
				printf("Connected to reference value server! \n");
			}

		}

		//Inicializacion de comunicacion dentro del hilo
		else if (counter == 2)
		{

			//Flujo optico
			//-------
			printf("Waiting for optical flow connection...\n");
			usleep(100);
			of_fifo = open("/tmp/of_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
			fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);

			if (FEAT_OF_ACTIVE)
			{
				read(of_fifo,(float*)(&of_data),sizeof(of_data));
				if (of_fifo<0)
				{
					printf("WARNING optical flow might not be running, %d!\n\n",of_fifo);
				}
				else
				{
					printf("Got optical flow connection, %d!\n",of_fifo);
				}

			}
			else
			{
				printf("Optical Flow deactivated! \n");
			}

          
            
			//Procesamiento de imagenes
			//-------
			printf("Waiting for image processing connection...\n");
			usleep(100);
			vis_fifo = open("/tmp/vis_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
			fcntl(vis_fifo, F_SETFL, fcntl(vis_fifo, F_GETFL) | O_NONBLOCK);

			if (FEAT_POSVIS_RUN)
            {

                
				read(vis_fifo,(float*)(&vis_data),sizeof(vis_data));
				if (vis_fifo<0)
				{
					printf("WARNING image processing might not be running, %d!\n",vis_fifo);
				}
				else
				{
					printf("Got image processing connection, %d !\n",vis_fifo);
                   
				}
			}
			else
			{
				printf("POSVIS computations deactivated! \n");
			};


			//inicializacion de sensores para Calibracion 
			//-----
			sensorCal[0] = in->HAL_acc_SI.x;
			sensorCal[1] = in->HAL_acc_SI.y;
			sensorCal[2] = in->HAL_acc_SI.z;
			sensorCal[3] = in->HAL_gyro_SI.x;
			sensorCal[4] = in->HAL_gyro_SI.y;
			sensorCal[5] = in->HAL_gyro_SI.z;
			sensorCal[6] = in->HAL_pressure_SI.pressure;

			battLevelAvg = (double)((int)in->HAL_vbat_SI.vbat_percentage);

			//Activacion de motores
			out->command = BLDC_CMD_START;
            
          

		}


		//s1: Calibracion de sensores
		else if (counter < calibCycles)
		{
			sensorCal[0] = sensorCal[0]*(counter-1)/counter + in->HAL_acc_SI.x/counter;
			sensorCal[1] = sensorCal[1]*(counter-1)/counter + in->HAL_acc_SI.y/counter;
			sensorCal[2] = sensorCal[2]*(counter-1)/counter + in->HAL_acc_SI.z/counter;
			sensorCal[3] = sensorCal[3]*(counter-1)/counter + in->HAL_gyro_SI.x/counter;
			sensorCal[4] = sensorCal[4]*(counter-1)/counter + in->HAL_gyro_SI.y/counter;
			sensorCal[5] = sensorCal[5]*(counter-1)/counter + in->HAL_gyro_SI.z/counter;
			sensorCal[6] = sensorCal[6]*(counter-1)/counter + in->HAL_pressure_SI.pressure/counter;

			battLevelAvg = battLevelAvg*(counter-1)/counter + (double)((int)in->HAL_vbat_SI.vbat_percentage)/counter;

			//Vaciado de Fifo
			if (FEAT_OF_ACTIVE)  read(of_fifo,(float*)(&of_data),sizeof(of_data));
			if (FEAT_POSVIS_RUN) read(vis_fifo,(float*)(&vis_data),sizeof(vis_data));


			//Salida de motores =0
			out->motors_speed[0] = 0;
			out->motors_speed[1] = 0;
			out->motors_speed[2] = 0;
			out->motors_speed[3] = 0;
			out->command = BLDC_CMD_STOP;
			return;
		}
		
		//s2: Inicializacion del modelo dinamico para control
		else if (counter==calibCycles)
			{
			printf("Batterylevel: %f\n",battLevelAvg);
			printf("Sensorcal: %f :: %f :: %f :: %f :: %f :: %f :: %f \n",sensorCal[0],sensorCal[1],9.81+sensorCal[2],sensorCal[3],sensorCal[4],sensorCal[5],sensorCal[6]);

			//Se para si no esta en superficie horizontal
			if ( (!FEAT_NOSAFETY) && abs(9.81+sensorCal[2]) > 0.7)
			{
				run_flag = 0;
				printf("ERROR: Please take off from a level surface! \n");
				out->motors_speed[0] = 0;
				out->motors_speed[1] = 0;
				out->motors_speed[2] = 0;
				out->motors_speed[3] = 0;
				out->command = BLDC_CMD_STOP;
				return;
			}



			//Inicializacion del modelo de simulink, Compensayor
			//----------

			  /* Pack model data into RTM */
			  DroneRS_Compensator_M->ModelData.defaultParam = &DroneRS_Compensator_P;
			  DroneRS_Compensator_M->ModelData.blockIO = &DroneRS_Compensator_B;
			  DroneRS_Compensator_M->ModelData.dwork = &DroneRS_Compensator_DW;

			  /* Initialize model */
			  DroneRS_Compensator_initialize(DroneRS_Compensator_M,
			    &DroneRS_Compensator_U_controlModePosVSAtt_flagin,
			    DroneRS_Compensator_U_pos_refin, DroneRS_Compensator_U_attRS_refin,
			    &DroneRS_Compensator_U_ddx, &DroneRS_Compensator_U_ddy,
			    &DroneRS_Compensator_U_ddz, &DroneRS_Compensator_U_p,
			    &DroneRS_Compensator_U_q, &DroneRS_Compensator_U_r,
			    &DroneRS_Compensator_U_altitude_sonar, &DroneRS_Compensator_U_prs,
			    DroneRS_Compensator_U_opticalFlowRS_datin,
			    DroneRS_Compensator_U_sensordatabiasRS_datin,
			    DroneRS_Compensator_U_posVIS_datin, &DroneRS_Compensator_U_usePosVIS_flagin,
			    DroneRS_Compensator_U_batteryStatus_datin,
			    DroneRS_Compensator_Y_motorsRS_cmdout, &DroneRS_Compensator_Y_X,
			    &DroneRS_Compensator_Y_Y, &DroneRS_Compensator_Y_Z,
			    &DroneRS_Compensator_Y_yaw, &DroneRS_Compensator_Y_pitch,
			    &DroneRS_Compensator_Y_roll, &DroneRS_Compensator_Y_dx,
			    &DroneRS_Compensator_Y_dy, &DroneRS_Compensator_Y_dz,
			    &DroneRS_Compensator_Y_pb, &DroneRS_Compensator_Y_qb,
			    &DroneRS_Compensator_Y_rb,
			    &DroneRS_Compensator_Y_controlModePosVSAtt_flagout,
			    DroneRS_Compensator_Y_poseRS_refout, &DroneRS_Compensator_Y_ddxb,
			    &DroneRS_Compensator_Y_ddyb, &DroneRS_Compensator_Y_ddzb,
			    &DroneRS_Compensator_Y_pa, &DroneRS_Compensator_Y_qa,
			    &DroneRS_Compensator_Y_ra, &DroneRS_Compensator_Y_altitude_sonarb,
			    &DroneRS_Compensator_Y_prsb, DroneRS_Compensator_Y_opticalFlowRS_datout,
			    DroneRS_Compensator_Y_sensordatabiasRS_datout,
			    DroneRS_Compensator_Y_posVIS_datout,
			    &DroneRS_Compensator_Y_usePosVIS_flagout,
			    DroneRS_Compensator_Y_batteryStatus_datout);

			  //-------------------
			  //-------------------

			//init optical flow and vision outputport in case that functionality is deactivated
			DroneRS_Compensator_U_posVIS_datin[0] = NO_VIS_X;
			DroneRS_Compensator_U_posVIS_datin[1] = 0.0;
			DroneRS_Compensator_U_posVIS_datin[2] = 0.0;
			DroneRS_Compensator_U_posVIS_datin[3] = 0.0;

			//Comprobacion si procesamiento de imagenes activado
			if ((FEAT_POSVIS_RUN) && (vis_fifo <0))
				{
				vis_fifo = open("/tmp/vis_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
				fcntl(vis_fifo, F_SETFL, fcntl(vis_fifo, F_GETFL) | O_NONBLOCK);
				if (vis_fifo<0) printf("WARNING image processing not connected!\n");
				}

			//Comprobacion si procesamiento flujo optico activado
			if ((FEAT_OF_ACTIVE) && (of_fifo <0))
				{
				of_fifo = open("/tmp/of_fifo",O_RDONLY); //O_NONBLOCK O_RDONLY
				fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);
				if (of_fifo<0) printf("ERROR optical flow not running!\n");
				run_flag = 0;
				}

			//Entrada de sensores en el modelo
			DroneRS_Compensator_U_sensordatabiasRS_datin[0] = sensorCal[0];
			DroneRS_Compensator_U_sensordatabiasRS_datin[1] = sensorCal[1];
			DroneRS_Compensator_U_sensordatabiasRS_datin[2] = 9.81+sensorCal[2];
			DroneRS_Compensator_U_sensordatabiasRS_datin[3] = sensorCal[3];
			DroneRS_Compensator_U_sensordatabiasRS_datin[4] = sensorCal[4];
			DroneRS_Compensator_U_sensordatabiasRS_datin[5] = sensorCal[5];
			DroneRS_Compensator_U_sensordatabiasRS_datin[6] = sensorCal[6];

		  
		   //Activacion de motores
  		    out->command = BLDC_CMD_RUN;

			}

		//s3: Vuelo
		else if (counter <= onCycles)
			{


			//3.1 Ajustes de despegue
			if (counter<calibCycles + takeoffCycles)
				{
				powerGain = powerGain_eparam;
				DroneRS_Compensator_U_pos_refin[2] = 1; //Activa el despegue

			       //Si la bateria esta baja...
	  			    if ((DroneRS_Compensator_U_batteryStatus_datin[1]<MIN_BATTTAKEOFF) && (DroneRS_Compensator_U_batteryStatus_datin[1]>0.1))
	  			    {						
					run_flag = 0;
					printf("Flight aborted due to low voltage (%f %%): shutting down motors now, charge battery!\n",DroneRS_Compensator_U_batteryStatus_datin[1]);
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
	  			    }
				}

			//3.2 Transicion a vuelo real, control
			else if (counter == calibCycles + takeoffCycles)
			{
                //Se define la altura deseada
				DroneRS_Compensator_U_pos_refin[2] = -0.7;

			}
			//3.3 Ajustes de vuelo real
			else if (counter<onCycles)
			{
                if(parar && c==0){
                    parar_flag = 1;
                    c = counter;
                }
                
				powerGain = powerGain_eparam;
                
                //Si entramos en modo parada desactivamos el control manual
                if(!parar_flag){

                    fcntl(sockfd, F_SETFL, O_NONBLOCK);
				memset(recvBuff, '\0', sizeof(recvBuff));
 			    recv(sockfd, recvBuff, sizeof(recvBuff),O_NONBLOCK);
                }
                //Aterrizaje progresivo
                if(parar_flag && counter < c +800){
                    DroneRS_Compensator_U_attRS_refin[1] = (double)0.001;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.001;
                }
                if(parar_flag && counter%100 == 0 && DroneRS_Compensator_U_pos_refin[2]<-0.15 && counter>c+800){
                    DroneRS_Compensator_U_attRS_refin[1] = (double)0.001;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.001;
                    //Cambio de altura
                    DroneRS_Compensator_U_pos_refin[2] = DroneRS_Compensator_U_pos_refin[2] + 0.15;
                    printf("\nCambio de altura a %f \n", DroneRS_Compensator_U_pos_refin[2]);
                    
                   
                }else if(parar_flag && counter%100==0 && DroneRS_Compensator_U_pos_refin[2]>-0.15){
                    printf("Apagando motores... \n");
                    
                    run_flag = 0;
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
                }
                
                //Experimento de cambios de altura
//                 if(counter==1000){
//                    DroneRS_Compensator_U_pos_refin[2] = -1.5;
//                 }else if(counter==1800){
//                    DroneRS_Compensator_U_pos_refin[2] = -0.5;
//                 }else if(counter==2400){
//                    DroneRS_Compensator_U_pos_refin[2] = -0.5;
//                 }
                        
                
                //Modificado Movimiento, trayectoria cuadrada
                if(mvto && counter<(calibCycles + takeoffCycles + 900) && counter>(calibCycles + takeoffCycles + 300 )){
                    //Si ya ha despegado y suponemos que estabilizado
                    //comienza movimiento hacia delante durante 200 ciclos = 1segundo
                    DroneRS_Compensator_U_attRS_refin[1] = (double)0.0;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)-0.04;
                    printf("1");
                    
                }else if(mvto && counter<(calibCycles + takeoffCycles + 1700) && counter>(calibCycles + takeoffCycles + 900 )){
                    DroneRS_Compensator_U_attRS_refin[1] = (double)0.0;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.0;
                }else if(mvto && counter <  (calibCycles + takeoffCycles + 2300) && counter>(calibCycles + takeoffCycles + 1700)){
                    //Ha pasado el tiempo, reseteamos posicion.
                    DroneRS_Compensator_U_attRS_refin[1] = (double)-0.07;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.0;
                    printf("2");
                    
                }else if(mvto && counter<(calibCycles + takeoffCycles + 3100) && counter>(calibCycles + takeoffCycles + 2300 )){
                     DroneRS_Compensator_U_attRS_refin[1] = (double)0.0;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.0;
                    
                }else if(mvto && counter<(calibCycles + takeoffCycles + 3700) && counter>(calibCycles + takeoffCycles + 3100 )){
                    DroneRS_Compensator_U_attRS_refin[1] = (double)0.0;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.04;
                    printf("3");
                }else if(mvto && counter<(calibCycles + takeoffCycles + 4500) && counter>(calibCycles + takeoffCycles + 3700 )){
                     DroneRS_Compensator_U_attRS_refin[1] = (double)0.0;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.0;
                    
                }else if(mvto && counter<(calibCycles + takeoffCycles + 5100) && counter>(calibCycles + takeoffCycles + 4500 )){
                    DroneRS_Compensator_U_attRS_refin[1] = (double)0.05;
                    DroneRS_Compensator_U_attRS_refin[2] = (double)0.0;
                    printf("4");
                }else {
                   // DroneRS_Compensator_U_attRS_refin[1] = (double)0.0;
                   // DroneRS_Compensator_U_attRS_refin[2] = (double)0.0;
                    
                }
  			    //Lectura de socket con teclado
  			    if ( (recvBuff[0])!='\0' )
  			    {

  			    	sscanf(recvBuff,"%i %i %i %i %i %i", &run_flag, &pitch_ref_buff,&roll_ref_buff,&yaw_ref_buff,&alt_ref_buff,&parar_flag);

                    DroneRS_Compensator_U_attRS_refin[0] = (double)((yaw_ref_buff-10000)/1000.0);
  			    	DroneRS_Compensator_U_attRS_refin[1] = (double)((pitch_ref_buff-10000)/1000.0);
  			    	DroneRS_Compensator_U_attRS_refin[2] = (double)((roll_ref_buff -10000)/1000.0);
  			    	if ( ((double)(alt_ref_buff/100.0)) >= -4.0)
  			    		{
  			    		DroneRS_Compensator_U_pos_refin[2]    = (double)(alt_ref_buff/100.0);
  			    		}
  			    }
                
                // Cambia de control en posicion y velocidad a control de los angulos
                // de Euler.
                if ((DroneRS_Compensator_U_attRS_refin[1]==0.0) && (DroneRS_Compensator_U_attRS_refin[2]==0.0))
  			    	DroneRS_Compensator_U_controlModePosVSAtt_flagin = 1; //1 ; 1 position reference, 0 angle reference
  			    else
  			    	//angle control
  			    	DroneRS_Compensator_U_controlModePosVSAtt_flagin = 0; //0 ; 1 position reference, 0 angle reference


  			    //Uso de estimacin por vision
  			    DroneRS_Compensator_U_usePosVIS_flagin = FEAT_POSVIS_USE;

  			    //Posible aborto de vuelo
  			    if (run_flag==0)
  			    {
					printf("Flight abort request: shutting down motors now\n");
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
  			    }

			}

			//3.4 Fin de vuelo por duracion maxima alcanzada
			else
			{
				powerGain = 0;

			};




			//Control de vuelo
			//---------------------

			//Deteccion de choque por acelerometro
			if ( (counter>(calibCycles + takeoffCycles+300)) && ((!FEAT_NOSAFETY) && ((abs(in->HAL_acc_SI.x) > MAX_ACCELL) || (abs(in->HAL_acc_SI.y) > MAX_ACCELL) ||  (in->HAL_acc_SI.z>0) ) )
					||
				  (( FEAT_NOSAFETY) && ((abs(in->HAL_acc_SI.x) > MAX_ACCELL*3) || (abs(in->HAL_acc_SI.y) > MAX_ACCELL*3)  ) )
				    ||
				    ((abs(DroneRS_Compensator_Y_X) > MAX_RANGE) || (abs(DroneRS_Compensator_Y_Y) > MAX_RANGE))
				)
			{
					run_flag = 0;
					if (((abs(DroneRS_Compensator_Y_X) > MAX_RANGE) || (abs(DroneRS_Compensator_Y_Y) > MAX_RANGE))) printf("Drone out of range: shutting down motors now\n");
					else printf("Flight crash detected (accelerometer): shutting down motors now\n");

					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;
			}
			//Deteccion de bateria baja
			if ((DroneRS_Compensator_U_batteryStatus_datin[1]<MIN_BATT) && (DroneRS_Compensator_U_batteryStatus_datin[1]>1.0))
			{
					run_flag = 0;
					printf("Flight aborted due to low voltage (%f %%): shutting down motors now, charge battery!\n",DroneRS_Compensator_U_batteryStatus_datin[1]);
					out->motors_speed[0] = 0;
					out->motors_speed[1] = 0;
					out->motors_speed[2] = 0;
					out->motors_speed[3] = 0;
					out->command = BLDC_CMD_STOP;
					return;	
			};


			//Input to Model: optical flow computations (setup as zero-order hold: no updates on static var when nothing new in fifo)
			if((FEAT_OF_ACTIVE) && (of_fifo>0))
			{
					
					if ( (read(of_fifo,(float*)(&of_data),sizeof(of_data)) > 0) && ( (of_data[0]!=0.0) || (of_data[1]!=0.0) ))
					{
						ofQuality = of_data[3];
						ofDefined = of_data[4];
						if (ofQuality>0)
						{
							counter_noOF = 0;
							DroneRS_Compensator_U_opticalFlowRS_datin[0] = (double)of_data[0];
							DroneRS_Compensator_U_opticalFlowRS_datin[1] = (double)of_data[1];
							DroneRS_Compensator_U_opticalFlowRS_datin[2] = (double)of_data[2];
						}
					}
					else
					{
						if ( counter>(calibCycles + takeoffCycles) )
						{
							counter_noOF += 1;

							if (counter_noOF>=MAX_noOF)
													{	run_flag = 0;
														printf("Problem with optical flow, there has been no flow for %d cycles in cycle %d: shutting down motors now\n",counter_noOF,counter);
														out->motors_speed[0] = 0;
														out->motors_speed[1] = 0;
														out->motors_speed[2] = 0;
														out->motors_speed[3] = 0;
														out->command = BLDC_CMD_STOP;
														return;
													}
						}


					};

			}


			//Input to Model: Calculo de procesamiento de imagenes 
            if((FEAT_POSVIS_RUN) && (vis_fifo>0))
			{

					if ((read(vis_fifo,(float*)(&vis_data),sizeof(vis_data)) > 0) && ((vis_data[0]!=0.0) || (vis_data[1]) || (vis_data[3]) ) )
					{
						DroneRS_Compensator_U_posVIS_datin[0] = (double)vis_data[0];
						DroneRS_Compensator_U_posVIS_datin[1] = (double)vis_data[1];
						DroneRS_Compensator_U_posVIS_datin[2] = (double)vis_data[2];
						DroneRS_Compensator_U_posVIS_datin[3] = (double)vis_data[3];

					}
					else
					{
						DroneRS_Compensator_U_posVIS_datin[0] = NO_VIS_X;
						DroneRS_Compensator_U_posVIS_datin[1] = 0.0;
						DroneRS_Compensator_U_posVIS_datin[2] = 0.0;
						DroneRS_Compensator_U_posVIS_datin[3] = 0.0;
					}

			}

			//Input to Model: datos de sensores
			DroneRS_Compensator_U_ddx 	= in->HAL_acc_SI.x;
			DroneRS_Compensator_U_ddy 	= in->HAL_acc_SI.y;
			DroneRS_Compensator_U_ddz 	= in->HAL_acc_SI.z;
			DroneRS_Compensator_U_p 	= in->HAL_gyro_SI.x;
			DroneRS_Compensator_U_q 	= in->HAL_gyro_SI.y;
			DroneRS_Compensator_U_r		= in->HAL_gyro_SI.z;
			DroneRS_Compensator_U_altitude_sonar	= in->HAL_ultrasound_SI.altitude;
			DroneRS_Compensator_U_prs 	= in->HAL_pressure_SI.pressure;

			DroneRS_Compensator_U_batteryStatus_datin[0] = in->HAL_vbat_SI.vbat_V;
			DroneRS_Compensator_U_batteryStatus_datin[1] = (double)((int)in->HAL_vbat_SI.vbat_percentage);

			if (rtmGetErrorStatus(DroneRS_Compensator_M) == (NULL)){
				rt_OneStep(DroneRS_Compensator_M);
			} else {
				run_flag = 0;
				printf("ERROR: Error from simulink model @ counter=%i !\n", counter);
				out->motors_speed[0] = 0;
				out->motors_speed[1] = 0;
				out->motors_speed[2] = 0;
				out->motors_speed[3] = 0;
				out->command = BLDC_CMD_STOP;
				return;
			}

			//power engines
			if (counter<onCycles)
				{
					out->command = BLDC_CMD_RUN;
				}
				else
				{
					out->command = BLDC_CMD_STOP;
					return;
				};


			// Actualizacion de los comandos de los motores
// 			out->motors_speed[0] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[0])));
// 			out->motors_speed[1] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[1])));
// 			out->motors_speed[2] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[2])));
// 			out->motors_speed[3] =  (int)(powerGain*(abs(DroneRS_Compensator_Y_motorsRS_cmdout[3])));
 			
         out->motors_speed[0] =  0;
			out->motors_speed[1] =  0;
			out->motors_speed[2] =  0;
			out->motors_speed[3] =  0;
			
                usleep(100);

			}

		//s4.0 Fin de vuelo

		else //counter=durTest+1
		{
			/* Matfile logging save*/
			printf("Saving logged data at end of flight... \n");
            
           // DroneRS_Compensator_U_pos_refin[2]    = (double)(alt_ref_buff/100.0);

			rt_StopDataLogging(MATFILE, DroneRS_Compensator_M->rtwLogInfo);
			if (FEAT_OF_ACTIVE)
			{
				close(of_fifo);
			}
			printf("Saving logged data... DONE \n");

			if (FEAT_TIME) {fclose(ptfile);}


			exit(0);
		}


		usleep(200);


		//ptiming - store
		//----------
		ptimer_stopstore(FEAT_TIME,counter,start, ptfile);
		//----------

}
